import { execSync } from "node:child_process";
import path from "node:path";
import fs from "node:fs";
import lmdb from "lmdb";
import test from "ava";
import createProject from "./_create-project.js";
import { getFilePathsInDirectory } from "../lib/utils.js";
let dir;
let db;

test.before(t => {
  dir = createProject("passthrough-copy");
  execSync("npx @11ty/eleventy", { cwd: dir });
  db = lmdb.open(path.join(dir, ".plugin-clean"));
});

test.after.always(t => {
  db.close();
});

test("paths in _site equal to paths in DB", async t => {
  let outputDir = path.join(dir, "_site");
  let outputPaths = await getFilePathsInDirectory(outputDir);
  // console.error({ outputPaths: outputPaths });

  // console.error("outputPaths in DB:");
  let numberOfSavedPaths = 0;
  for (let key of db.getKeys({ start: 2 })) {
    // console.error(key);
    numberOfSavedPaths++;
  }
  t.is(numberOfSavedPaths, outputPaths.length);

  for (let outputPath of outputPaths) {
    outputPath = path.relative(dir, outputPath);
    t.is(db.get(outputPath), 1, `Not found value for output path: ${ outputPath }`);
  }
});

test("save output paths generated by addPassthroughCopy(\"**/*.foo\") to DB", async t => {
  t.notThrows(() => fs.statSync(path.join(dir, "_site", "a.foo")));
  t.notThrows(() => fs.statSync(path.join(dir, "_site", "b/c.foo")));

  t.is(db.get(path.normalize("_site/a.foo")), 1);
  t.is(db.get(path.normalize("_site/b/c.foo")), 1);
});

test("save output paths generated by addPassthroughCopy({ \"**/*.bar\": \"baz\" }) to DB", async t => {
  t.notThrows(() => fs.statSync(path.join(dir, "_site", "baz/d.bar")));
  t.notThrows(() => fs.statSync(path.join(dir, "_site", "baz/f.bar")));
  t.notThrows(() => fs.statSync(path.join(dir, "_site", "baz/h.bar")));

  t.is(db.get(path.normalize("_site/baz/d.bar")), 1);
  t.is(db.get(path.normalize("_site/baz/f.bar")), 1);
  t.is(db.get(path.normalize("_site/baz/h.bar")), 1);
});

test("save output paths generated by addPassthroughCopy(\"qux/qux\") to DB, when \"qux/qux\" is a directory", async t => {
  t.notThrows(() => fs.statSync(path.join(dir, "_site", "qux/qux/i")));
  t.notThrows(() => fs.statSync(path.join(dir, "_site", "qux/qux/j/k")));

  t.is(db.get(path.normalize("_site/qux/qux/i")), 1);
  t.is(db.get(path.normalize("_site/qux/qux/j/k")), 1);
});

test("save output paths generated by addPassthroughCopy({ \"quux/quux\": \"quuz\" }) to DB, when \"quux/quux\" is a directory", async t => {
  t.notThrows(() => fs.statSync(path.join(dir, "_site", "quuz/l")));
  t.notThrows(() => fs.statSync(path.join(dir, "_site", "quuz/m/n")));

  t.is(db.get(path.normalize("_site/quuz/l")), 1);
  t.is(db.get(path.normalize("_site/quuz/m/n")), 1);
});

test("save output path generated by addPassthroughCopy(\"corge/corge\") to DB, when \"corge/corge\" is a file", async t => {
  t.notThrows(() => fs.statSync(path.join(dir, "_site", "corge/corge")));

  t.is(db.get(path.normalize("_site/corge/corge")), 1);
});

test("save output path generated by addPassthroughCopy({ \"grault/grault\": \"garply\" }) to DB, when \"grault/grault\" is a file", async t => {
  t.notThrows(() => fs.statSync(path.join(dir, "_site", "garply")));

  t.is(db.get(path.normalize("_site/garply")), 1);
});

