import { execSync } from "child_process";
import path from "path";
import fs from "fs";
import lmdb from "lmdb";
import test from "ava";
import createProject from "./_create-project.js";
import { getFilePathsInDirectory } from "../lib/utils.js";
let dir;
let db;

test.before(t => {
  dir = createProject("passthrough-copy-directories-configured", "eleventy-project-directories-configured");
  execSync("npx @11ty/eleventy", { cwd: dir });
  db = lmdb.open(path.join(dir, ".plugin-clean"));
});

test.after.always(t => {
  db.close();
});

test("paths in \"dist\" equals to paths in DB", async t => {
  let outputDir = path.join(dir, "dist");
  let outputPaths = await getFilePathsInDirectory(outputDir);
  // console.error({ outputPaths: outputPaths });

  // console.error("outputPaths in DB:");
  let numberOfSavedPaths = 0;
  for (let key of db.getKeys({ start: 2 })) {
    // console.error(key);
    numberOfSavedPaths++;
  }
  t.is(numberOfSavedPaths, outputPaths.length);

  for (let outputPath of outputPaths) {
    outputPath = path.relative(dir, outputPath);
    t.is(db.get(outputPath), 1, `Not found value for output path: ${ outputPath }`);
  }
});

test("save output paths generated by addPassthroughCopy(\"**/*.foo\") to DB", async t => {
  t.notThrows(() => fs.statSync(path.join(dir, "dist", "a.foo")));
  t.notThrows(() => fs.statSync(path.join(dir, "dist", "b/c.foo")));
  t.notThrows(() => fs.statSync(path.join(dir, "dist", "d.foo")));
  t.notThrows(() => fs.statSync(path.join(dir, "dist", "e/f.foo")));

  t.is(db.get(path.normalize("dist/a.foo")), 1);
  t.is(db.get(path.normalize("dist/b/c.foo")), 1);
  t.is(db.get(path.normalize("dist/d.foo")), 1);
  t.is(db.get(path.normalize("dist/e/f.foo")), 1);
});

test("save output paths generated by addPassthroughCopy({ \"**/*.bar\": \"baz\" }) to DB", async t => {
  t.notThrows(() => fs.statSync(path.join(dir, "dist", "baz/g.bar")));
  t.notThrows(() => fs.statSync(path.join(dir, "dist", "baz/i.bar")));
  t.notThrows(() => fs.statSync(path.join(dir, "dist", "baz/j.bar")));
  t.notThrows(() => fs.statSync(path.join(dir, "dist", "baz/l.bar")));

  t.is(db.get(path.normalize("dist/baz/g.bar")), 1);
  t.is(db.get(path.normalize("dist/baz/i.bar")), 1);
  t.is(db.get(path.normalize("dist/baz/j.bar")), 1);
  t.is(db.get(path.normalize("dist/baz/l.bar")), 1);
});

test("save output paths generated by addPassthroughCopy(\"src/**/*.qux\") to DB", async t => {
  t.notThrows(() => fs.statSync(path.join(dir, "dist", "n.qux")));
  t.notThrows(() => fs.statSync(path.join(dir, "dist", "o/p.qux")));

  t.is(db.get(path.normalize("dist/n.qux")), 1);
  t.is(db.get(path.normalize("dist/o/p.qux")), 1);
});

test("save output paths generated by addPassthroughCopy({ \"src/**/*.quux\": \"quuz\" }) to DB", async t => {
  t.notThrows(() => fs.statSync(path.join(dir, "dist", "quuz/r.quux")));
  t.notThrows(() => fs.statSync(path.join(dir, "dist", "quuz/t.quux")));

  t.is(db.get(path.normalize("dist/quuz/r.quux")), 1);
  t.is(db.get(path.normalize("dist/quuz/t.quux")), 1);
});

test("save output paths generated by addPassthroughCopy(\"corge/corge\") to DB, when \"corge/corge\" is a directory", async t => {
  t.notThrows(() => fs.statSync(path.join(dir, "dist", "corge/corge/u")));
  t.notThrows(() => fs.statSync(path.join(dir, "dist", "corge/corge/v/w")));

  t.is(db.get(path.normalize("dist/corge/corge/u")), 1);
  t.is(db.get(path.normalize("dist/corge/corge/v/w")), 1);
});

test("save output paths generated by addPassthroughCopy({ \"grault/grault\": \"garply\" }) to DB, when \"grault/grault\" is a directory", async t => {
  t.notThrows(() => fs.statSync(path.join(dir, "dist", "garply/aa")));
  t.notThrows(() => fs.statSync(path.join(dir, "dist", "garply/bb/cc")));

  t.is(db.get(path.normalize("dist/garply/aa")), 1);
  t.is(db.get(path.normalize("dist/garply/bb/cc")), 1);
});

test("save output path generated by addPassthroughCopy(\"waldo/waldo\") to DB, when \"waldo/waldo\" is a file", async t => {
  t.notThrows(() => fs.statSync(path.join(dir, "dist", "waldo/waldo")));

  t.is(db.get(path.normalize("dist/waldo/waldo")), 1);
});

test("save output path generated by addPassthroughCopy({ \"fred/fred\": \"plugh\" }) to DB, when \"fred/fred\" is a file", async t => {
  t.notThrows(() => fs.statSync(path.join(dir, "dist", "plugh")));

  t.is(db.get(path.normalize("dist/plugh")), 1);
});


test("save output paths generated by addPassthroughCopy(\"src/xyzzy/xyzzy\") to DB, when \"src/xyzzy/xyzzy\" is a directory", async t => {
  t.notThrows(() => fs.statSync(path.join(dir, "dist", "xyzzy/xyzzy/jj")));
  t.notThrows(() => fs.statSync(path.join(dir, "dist", "xyzzy/xyzzy/kk/ll")));

  t.is(db.get(path.normalize("dist/xyzzy/xyzzy/jj")), 1);
  t.is(db.get(path.normalize("dist/xyzzy/xyzzy/kk/ll")), 1);
});

test("save output paths generated by addPassthroughCopy({ \"src/thud/thud\": \"hoge\" }) to DB, when \"src/thud/thud\" is a directory", async t => {
  t.notThrows(() => fs.statSync(path.join(dir, "dist", "hoge/pp")));
  t.notThrows(() => fs.statSync(path.join(dir, "dist", "hoge/qq/rr")));

  t.is(db.get(path.normalize("dist/hoge/pp")), 1);
  t.is(db.get(path.normalize("dist/hoge/qq/rr")), 1);
});

test("save output path generated by addPassthroughCopy(\"src/fuga/fuga\") to DB, when \"src/fuga/fuga\" is a file", async t => {
  t.notThrows(() => fs.statSync(path.join(dir, "dist", "fuga/fuga")));

  t.is(db.get(path.normalize("dist/fuga/fuga")), 1);
});

test("save output path generated by addPassthroughCopy({ \"src/piyo/piyo\": \"hogera\" }) to DB, when \"src/piyo/piyo\" is a file", async t => {
  t.notThrows(() => fs.statSync(path.join(dir, "dist", "hogera")));

  t.is(db.get(path.normalize("dist/hogera")), 1);
});
